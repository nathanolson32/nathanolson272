//1) Store the first k elements in a temporary array temp[0..k-1]. 
//2) Find the smallest element in temp[], let the smallest element be min. 
//3-a) For each element x in arr[k] to arr[n-1]. O(n-k) 
//If x is greater than the min then remove min from temp[] and insert x. 
//3-b)Then, determine the new min from temp[]. O(k) 
//4) Print final k elements of temp[]

//Time Complexity: O((n-k)*k). If we want the output sorted then O((n-k)*k + k*log(k))
//Thanks to nesamani1822 for suggesting this method. 

//Method 3(Use Sorting) 
//1) Sort the elements in descending order in O(n*log(n)) 
//2) Print the first k numbers of the sorted array O(k). 

// Java code for k largest elements in an array
import java.util.Arrays;
import java.util.Collections;
import java.util.ArrayList;
 
class GFG {
    public static void kLargest(Integer[] arr, int k)  {
        // Sort the given array arr in reverse order
        // This method doesn't work with primitive data
        // types. So, instead of int, Integer type
        // array will be used
        Arrays.sort(arr, Collections.reverseOrder());
 
        // Print the first kth largest elements
        for (int i = 0; i < k; i++)
            System.out.print(arr[i] + " ");
    }
   
  public static ArrayList<Integer> kLargest(int[] arr, int k)
    {
        //Convert using stream
        Integer[] obj_array = Arrays.stream( arr ).boxed().toArray( Integer[] :: new);
        Arrays.sort(obj_array, Collections.reverseOrder());
        ArrayList<Integer> list = new ArrayList<>(k);
 
        for (int i = 0; i < k; i++)
            list.add(obj_array[i]);
     
        return list;
    }
 
    public static void main(String[] args)
    {
        Integer arr[] = new Integer[] { 1, 23, 12, 9,
                                        30, 2, 50 };
        int k = 3;
        kLargest(arr, k);
       
        //What if primitive datatype array is passed and wanted to return in ArrayList<Integer>
        int[] prim_array = { 1, 23, 12, 9, 30, 2, 50 };
          System.out.print(kLargest(prim_array, k));
    }
}
//Output
//50 30 23 
//Time complexity: O(n*log(n))

//Method 4 (Use Max Heap) 
//1) Build a Max Heap tree in O(n) 
//2) Use Extract Max k times to get k maximum elements from the Max Heap O(k*log(n))

//Time complexity: O(n + k*log(n))



//Method 5(Use Order Statistics) 
//1) Use an order statistic algorithm to find the kth largest element. Please see the topic selection in worst-case linear time O(n) 
//2) Use QuickSort Partition algorithm to partition around the kth largest number O(n). 
//3) Sort the k-1 elements (elements greater than the kth largest element) O(k*log(k)). This step is needed only if the sorted output is required.

//Time complexity: O(n) if we don’t need the sorted output, otherwise O(n+k*log(k))
//Thanks to Shilpi for suggesting the first two approaches.

//Method 6 (Use Min Heap) 
//This method is mainly an optimization of method 1. Instead of using temp[] array, use Min Heap.
//1) Build a Min Heap MH of the first k elements (arr[0] to arr[k-1]) of the given array. O(k*log(k))
//2) For each element, after the kth element (arr[k] to arr[n-1]), compare it with root of MH. 
//……a) If the element is greater than the root then make it root and call heapify for MH 
//……b) Else ignore it. 
// The step 2 is O((n-k)*log(k))
//3) Finally, MH has k largest elements, and the root of the MH is the kth largest element.
//Time Complexity: O(k*log(k) + (n-k)*log(k)) without sorted output. If sorted output is needed then O(k*log(k) + (n-k)*log(k) + k*log(k)) so overall it is O(k*log(k) + (n-k)*log(k))

//All of the above methods can also be used to find the kth largest (or smallest) element.


import java.io.*;
import java.util.*;
 
class GFG{
   
public static void FirstKelements(int arr[],
                                  int size,
                                  int k)
{
     
    // Creating Min Heap for given
    // array with only k elements
    // Create min heap with priority queue
    PriorityQueue<Integer> minHeap = new PriorityQueue<>();
    for(int i = 0; i < k; i++)
    {
        minHeap.add(arr[i]);
    }
     
    // Loop For each element in array
    // after the kth element
    for(int i = k; i < size; i++)
    {
         
        // If current element is smaller
        // than minimum ((top element of
        // the minHeap) element, do nothing
        // and continue to next element
        if (minHeap.peek() > arr[i])
            continue;
         
        // Otherwise Change minimum element
        // (top element of the minHeap) to
        // current element by polling out
        // the top element of the minHeap
        else
        {
            minHeap.poll();
            minHeap.add(arr[i]);
        }
    }
     
    // Now min heap contains k maximum
    // elements, Iterate and print
    Iterator iterator = minHeap.iterator();
     
    while (iterator.hasNext())
    {
        System.out.print(iterator.next() + " ");
    }
}
 
// Driver code
public static void main (String[] args)
{
    int arr[] = { 11, 3, 2, 1, 15, 5, 4,
                  45, 88, 96, 50, 45 };
     
    int size = arr.length;
     
    // Size of Min Heap
    int k = 3;
     
    FirstKelements(arr, size, k);
}
}
 
Output
50 88 96 
Method 7(Using Quick Sort partitioning algorithm):

Choose a pivot number.
if K is lesser than the pivot_Index then repeat the step.
if K == pivot_Index : Print the array (low to pivot to get K-smallest elements and (n-pivot_Index) to n fotr K-largest elements)
if  K > pivot_Index : Repeat the steps for right part.
We can improve on the standard quicksort algorithm by using the random() function. Instead of using the pivot element as the last element, we can randomly choose the pivot element. The worst-case time complexity of this version is O(n2) and the average time complexity is O(n).

Following is the implementation of the above algorithm:


#include <bits/stdc++.h>
using namespace std;
 
//picks up last element between start and end
int findPivot(int a[], int start, int end)
{
     
    // Selecting the pivot element
    int pivot = a[end];
   
    // Initially partition-index will be
    // at starting
    int pIndex = start;
 
    for (int i = start; i < end; i++) {
       
        // If an element is lesser than pivot, swap it.
        if (a[i] <= pivot) {
            swap(a[i], a[pIndex]);
           
            // Incrementing pIndex for further
            // swapping.
            pIndex++;
        }
    }
   
    // Lastly swapping or the
    // correct position of pivot
    swap(a[pIndex], a[end]);
    return pIndex;
}
 
 
//Picks up random pivot element between start and end
int findRandomPivot(int arr[], int start, int end)
{
    int n = end - start + 1;
    // Selecting the random pivot index
    int pivotInd = random()%n;
      swap(arr[end],arr[start+pivotInd]);
      int pivot = arr[end];
      //initialising pivoting point to start index
    pivotInd = start;
    for (int i = start; i < end; i++) {
       
        // If an element is lesser than pivot, swap it.
        if (arr[i] <= pivot) {
            swap(arr[i], arr[pivotInd]);
           
            // Incrementing pivotIndex for further
            // swapping.
            pivotInd++;
        }
    }
   
    // Lastly swapping or the
    // correct position of pivot
    swap(arr[pivotInd], arr[end]);
    return pivotInd;
}
//THIS PART OF CODE IS CONTRIBUTED BY - rjrachit
 
void SmallestLargest(int a[], int low, int high, int k,
                     int n)
{
    if (low == high)
        return;
    else {
        int pivotIndex = findRandomPivot(a, low, high);
 
        if (k == pivotIndex) {
            cout << k << " smallest elements are : ";
            for (int i = 0; i < pivotIndex; i++)
                cout << a[i] << "  ";
 
            cout << endl;
 
            cout << k << " largest elements are : ";
            for (int i = (n - pivotIndex); i < n; i++)
                cout << a[i] << "  ";
        }
 
        else if (k < pivotIndex)
            SmallestLargest(a, low, pivotIndex - 1, k, n);
 
        else if (k > pivotIndex)
            SmallestLargest(a, pivotIndex + 1, high, k, n);
    }
}
 
// Driver Code
int main()
{
    int a[] = { 11, 3, 2, 1, 15, 5, 4, 45, 88, 96, 50, 45 };
    int n = sizeof(a) / sizeof(a[0]);
 
    int low = 0;
    int high = n - 1;
   
    // Lets assume k is 3
    int k = 4;
 
    // Function Call
    SmallestLargest(a, low, high, k, n);
 
    return 0;
}
Output
3 smallest elements are : 3  2  1  
3 largest elements are : 96  50  88  
